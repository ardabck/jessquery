<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <button id="button">Click me!</button>
    <button id="button">Click me!</button>
    <div class="display"></div>
    <span class="spans"></span>
    <hr />
    <span class="spans"></span>
    <script type="module">
      import { $, $$ } from "../index.js"

      const fadeIn = { opacity: 1 }
      const fadeOut = { opacity: 0 }
      const oneSecond = 1000
      const buttons = $$("button")

      buttons
        .addClass("btn")
        .wait(1000)
        .attach(
          `<p>
              "These buttons will animate in 2 seconds. They will fade in and out twice
              then disappear."
          </p>`
        )
        .wait(2000)
        .transition(fadeIn, oneSecond)
        .transition(fadeOut, oneSecond)
        .transition(fadeIn, oneSecond)
        .transition(fadeOut, oneSecond)
        .purge()
      // // Use $ to select a single element.
      const display = $(".display")
      // const button = $("#button")

      // // Use $$ to select multiple elements.
      // const spans = $$(".spans")

      display
        .defer((el) => el.css("color", "blue"))
        .text("HALF A SECOND OF GLORY") // Text is black
        .wait(500)
        .text("Hello, world!") // Text is red
        .css("color", "red") // Both are synchronous, so it doesn't matter which order you put them in.
        .wait(500)
        .text("Goodbye, world!") // Text is blue

      // // These elements are now wrapped in a proxy with extra methods.
      // // They each have an internal queue that always executes in order.
      // // So, the chains are not only convenient and readable, but they're also predictable.

      // // You can even do async stuff!
      // async function fetchData() {
      //   await new Promise((resolve) => setTimeout(resolve, 2000))
      //   const response = await fetch(
      //     "https://jsonplaceholder.typicode.com/users/1"
      //   )
      //   const data = await response.json()
      //   return data.name
      // }

      // // promisify is for setTimeout/anything async that doesn't return a promise.
      // // (You can also just return a promise yourself if you want, but this has a few extra features.)
      // // Whatever you pass to resolve will be passed to whatever method you're calling.
      // // If you call reject, the reason will be passed to the error handler.
      // // However, if neither one is called, the chain will wait for a timer to expire.
      // // This is to keep you from accidentally halting the chain forever if no condition is met.
      // // It's set to five seconds by default, and it will resolve the promise without a value.
      // // You can pass a second argument to customize the amount of time to wait.
      // const onlyWarnIfLoadIsSlow = promisify(
      //   (resolve, reject) => {
      //     let displayText = display.textContent // capture a snapshot of the text
      //     setTimeout(() => {
      //       if (displayText === display.textContent) {
      //         resolve("Loading...")
      //         // if the text hasn't changed, then the fetch is taking too long
      //       }
      //     }, 200)
      //   }
      //   // 500, // <-- This is where you can customize the timeout.
      //   // {
      //   //   fnName: "onlyWarnIfLoadIsSlow",
      //   //   fnArgs: ["Your", "Arguments", "Here"], // You can also pass any metadata that you want the error handler to have.
      //   // }
      // )

      // // Every promise is resolved automatically
      // // The next function never runs until the previous one is finished.
      // // However, event handlers are given special priority-- so everything inside runs eagerly.
      // // This is so the user doesn't get frustrated while waiting for your events to fire.
      // button.on("click", () => {
      //   display
      //     .defer((el) => el.css("color", "red"))
      //     .text(onlyWarnIfLoadIsSlow()) // <-- This will NEVER show UNLESS fetchData takes longer than 200ms.
      //     .text(fetchData()) // <-- You don't have to await anything! It just works.
      // })

      // const fadeIn = { opacity: 1 }
      // const fadeOut = { opacity: 0 }
      // const oneSecond = 1000

      // spans
      //   .text(
      //     "This text will animate in 5 seconds. It will fade in and out then disappear."
      //   )
      //   .defer((el) => el.css("color", "green"))
      //   .addClass("btn")
      //   .wait(2000)
      //   .transition(fadeIn, oneSecond)
      //   .transition(fadeOut, oneSecond)
      //   .purge()
    </script>
  </body>
</html>
